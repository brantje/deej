package main

import (
	"bytes"
	"errors"
	"fmt"
	"image"
	"image/color"
	"image/png"
	"log"
	"math/rand"
	"os"

	"github.com/fcjr/geticon"
	"github.com/jacobsa/go-serial/serial"
	"github.com/nfnt/resize"

	"github.com/shirou/gopsutil/v3/process"
)

type ImageType string

const (
	ICON_SMALL           = 0
	ICON_BIG             = 1
	JPEG       ImageType = "jpeg"
	PNG        ImageType = "png"
	GIF        ImageType = "gif"
	BMP        ImageType = "bmp"
	UNKNOWN    ImageType = "unknown"
)

func main() {

	options := serial.OpenOptions{
		PortName:              "COM15",
		BaudRate:              115200,
		DataBits:              8,
		StopBits:              1,
		MinimumReadSize:       4,
		InterCharacterTimeout: 100,
	}

	port, err := serial.Open(options)
	if err != nil {
		log.Fatalf("serial.Open: %v", err)
	}
	defer port.Close()

	//============== Send an PNG file to a display ==============

	imagePath := "test.png"
	byteSlice, err := os.ReadFile(imagePath)
	if err != nil {
		log.Fatalf("Failed to read file: %v", err)
	}

	// For demonstration purposes, print the length of the byte slice
	// fmt.Printf("Loaded %s with size %d bytes\n", imagePath, len(byteSlice))

	img, err := png.Decode(bytes.NewReader(byteSlice))
	if err != nil {
		log.Fatalf("Load BMP icon: %v", err)
	}

	byteSlice = convertForDisplay(img, false)

	sendData := append([]byte("<<START>>1|"), byteSlice...)
	sendData = append(sendData, []byte("<<END>>.....")...)

	_, err = port.Write(sendData)
	if err != nil {
		log.Fatalf("port.Write: %v", err)
	}

	//============== Send an process icon to a display ==============
	// Note: Not all applications work yet

	procs, err := process.Processes()
	n := rand.Int() % len(procs)
	randomProc := procs[n]
	process, _ := randomProc.Name()
	fmt.Printf("Fetching process info of %s\n", process)
	pid, err := GetPIDByExeName(process)
	if err != nil {
		log.Fatal(err)
	}
	icon, err := geticon.FromPid(pid)

	if err != nil {
		log.Fatalf("Fetch icon: %v", err)
	}

	bw := convertForDisplay(icon, true)

	// sendData := []byte{}
	sendData = append([]byte("<<START>>2|"), bw...)
	sendData = append(sendData, []byte("<<END>>.....")...)

	_, err = port.Write(sendData)
	if err != nil {
		log.Fatalf("port.Write: %v", err)
	}

	// Speaker icons on the remaining screens
	speakerIcon := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x1f, 0xf8, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x3f, 0xfc, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x7f, 0xfe, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x7f, 0xfe, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc1, 0xff, 0xff, 0x83, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc1, 0xff, 0xff, 0x83, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x7f, 0xfe, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x3f, 0xfc, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x1f, 0xf8, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x0f, 0xf0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

	for i := 3; i < 5; i++ {
		sendData = append([]byte(fmt.Sprintf("<<START>>%d|", i)), speakerIcon...)
		sendData = append(sendData, []byte("<<END>>.....")...)

		_, err = port.Write(sendData)
		if err != nil {
			log.Fatalf("port.Write: %v", err)
		}
	}

	buf := make([]byte, 512)

	for {
		n, err := port.Read(buf)
		if err != nil {
			log.Fatal(err)
		}
		s := string(buf[:n])
		if s != "" {
			fmt.Println(s)
		}
	}
}

// DetectImageTypeFromImage detects the image type of an image.Image
func DetectImageTypeFromImage(img image.Image) (ImageType, error) {
	buf := new(bytes.Buffer)
	err := png.Encode(buf, img) // Using PNG as the common format
	if err != nil {
		return UNKNOWN, err
	}

	return DetectImageType(buf.Bytes())
}

// DetectImageType detects the image type based on its magic numbers.
func DetectImageType(data []byte) (ImageType, error) {
	if len(data) < 4 {
		return UNKNOWN, errors.New("data too short for image detection")
	}
	fmt.Printf("%#02x\n", data[0])
	switch {
	case data[0] == 0xFF && data[1] == 0xD8:
		return JPEG, nil
	case data[0] == 0x89 && data[1] == 'P' && data[2] == 'N' && data[3] == 'G':
		return PNG, nil
	case data[0] == 'G' && data[1] == 'I' && data[2] == 'F':
		return GIF, nil
	case data[0] == 'B' && data[1] == 'M':
		return BMP, nil
	case data[0] == 'B' && data[1] == 'M':
		return BMP, nil
	default:
		return UNKNOWN, nil
	}
}

func GetPIDByExeName(exeName string) (uint32, error) {
	procs, err := process.Processes()
	if err != nil {
		return 0, err
	}

	for _, p := range procs {
		name, err := p.Name()
		if err == nil && name == exeName {
			return uint32(p.Pid), nil
		}
	}

	return 0, fmt.Errorf("no process found with exe name: %s", exeName)
}

func convertForDisplay(src image.Image, doResize bool) []byte {
	// imageType, err := DetectImageTypeFromImage(src)
	// if err != nil {
	// 	fmt.Println(err)
	// 	return []byte{}
	// }
	// fmt.Printf("Detected icon image type: %s\n", imageType)
	// Resize to 50x50
	fmt.Println("Converting icon to for display")
	var resizedImg image.Image
	if doResize {
		fmt.Println("Resize to 60x60")
		resizedImg = resize.Resize(60, 60, src, resize.Lanczos3)
	} else {
		resizedImg = src
	}
	// Create a blank canvas of size 128x64
	fmt.Println("Create new 128x64 image")
	canvas := image.NewRGBA(image.Rect(0, 0, 128, 64))

	// Compute the top-left corner coordinates for centering the image
	startX := (canvas.Bounds().Dx() - resizedImg.Bounds().Dx()) / 2
	startY := (canvas.Bounds().Dy() - resizedImg.Bounds().Dy()) / 2

	fmt.Println("Draw image on center")
	// Draw the resized image onto the canvas
	for y := 0; y < resizedImg.Bounds().Dy(); y++ {
		for x := 0; x < resizedImg.Bounds().Dx(); x++ {
			canvas.Set(startX+x, startY+y, resizedImg.At(x, y))
		}
	}

	// Convert the canvas to black and white
	fmt.Println("Convert to black and white")
	// bwImg := toBlackAndWhite(canvas)

	fmt.Println("Coverting to 1 bit image")
	buf := encode1Bit(canvas)

	return buf
}

func encode1Bit(img image.Image) []byte {
	sz := img.Bounds()
	buff := new(bytes.Buffer)

	var currentByte uint8
	var bitPosition uint8 = 7

	for y := sz.Min.Y; y < sz.Max.Y; y++ {
		for x := sz.Min.X; x < sz.Max.X; x++ {
			c := color.GrayModel.Convert(img.At(x, y)).(color.Gray)
			if c.Y > 127 {
				currentByte |= (1 << bitPosition)
			}

			if bitPosition == 0 { // If we've set all bits for the current byte
				buff.WriteByte(currentByte)
				currentByte = 0
				bitPosition = 7
			} else {
				bitPosition--
			}
		}
	}

	// Write any remaining bits
	if bitPosition != 7 {
		buff.WriteByte(currentByte)
	}

	return buff.Bytes()
}
