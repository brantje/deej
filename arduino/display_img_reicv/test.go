package main

import (
	"bytes"
	"errors"
	"fmt"
	"image"
	"image/color"
	"image/png"
	"log"
	"os"

	"github.com/fcjr/geticon"
	"github.com/jacobsa/go-serial/serial"
	"github.com/nfnt/resize"

	"github.com/shirou/gopsutil/v3/process"
)

type ImageType string

const (
	ICON_SMALL           = 0
	ICON_BIG             = 1
	JPEG       ImageType = "jpeg"
	PNG        ImageType = "png"
	GIF        ImageType = "gif"
	BMP        ImageType = "bmp"
	UNKNOWN    ImageType = "unknown"
)

func main() {

	options := serial.OpenOptions{
		PortName:              "COM15",
		BaudRate:              115200,
		DataBits:              8,
		StopBits:              1,
		MinimumReadSize:       4,
		InterCharacterTimeout: 100,
	}

	port, err := serial.Open(options)
	if err != nil {
		log.Fatalf("serial.Open: %v", err)
	}
	defer port.Close()

	//============== Send an PNG file to a display ==============

	imagePath := "test.png"
	byteSlice, err := os.ReadFile(imagePath)
	if err != nil {
		log.Fatalf("Failed to read file: %v", err)
	}

	// For demonstration purposes, print the length of the byte slice
	// fmt.Printf("Loaded %s with size %d bytes\n", imagePath, len(byteSlice))

	img, err := png.Decode(bytes.NewReader(byteSlice))
	if err != nil {
		log.Fatalf("Load BMP icon: %v", err)
	}

	byteSlice = encode1Bit(img)

	sendData := append([]byte("<<START>>1|"), byteSlice...)
	sendData = append(sendData, []byte("<<END>>.....")...)

	_, err = port.Write(sendData)
	if err != nil {
		log.Fatalf("port.Write: %v", err)
	}

	//============== Send an process icon to a display ==============
	// Note: Not all applications work yet

	process := "firefox.exe"
	fmt.Printf("Fetching process info of %s\n", process)
	pid, err := GetPIDByExeName(process)
	if err != nil {
		log.Fatal(err)
	}
	icon, err := geticon.FromPid(pid)

	if err != nil {
		log.Fatalf("Fetch icon: %v", err)
	}
	imageType, err := DetectImageTypeFromImage(icon)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Detected icon image type: %s\n", imageType)

	bw := convertForDisplay(icon)

	// sendData := []byte{}
	sendData = append([]byte("<<START>>2|"), bw...)
	sendData = append(sendData, []byte("<<END>>.....")...)

	_, err = port.Write(sendData)
	if err != nil {
		log.Fatalf("port.Write: %v", err)
	}

	// Speaker icons on the remaining screens
	speakerIcon := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x1f, 0xf8, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x3f, 0xfc, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x7f, 0xfe, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x7f, 0xfe, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc1, 0xff, 0xff, 0x83, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc1, 0xff, 0xff, 0x83, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xff, 0xff, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x7f, 0xfe, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x3f, 0xfc, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x1f, 0xf8, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x0f, 0xf0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

	for i := 3; i < 5; i++ {
		sendData = append([]byte(fmt.Sprintf("<<START>>%d|", i)), speakerIcon...)
		sendData = append(sendData, []byte("<<END>>.....")...)

		_, err = port.Write(sendData)
		if err != nil {
			log.Fatalf("port.Write: %v", err)
		}
	}

	buf := make([]byte, 1024)

	for {
		n, err := port.Read(buf)
		if err != nil {
			log.Fatal(err)
		}
		s := string(buf[:n])
		fmt.Println(s)
	}

}

// DetectImageTypeFromImage detects the image type of an image.Image
func DetectImageTypeFromImage(img image.Image) (ImageType, error) {
	buf := new(bytes.Buffer)
	err := png.Encode(buf, img) // Using PNG as the common format
	if err != nil {
		return UNKNOWN, err
	}

	return DetectImageType(buf.Bytes())
}

// DetectImageType detects the image type based on its magic numbers.
func DetectImageType(data []byte) (ImageType, error) {
	if len(data) < 4 {
		return UNKNOWN, errors.New("data too short for image detection")
	}

	switch {
	case data[0] == 0xFF && data[1] == 0xD8:
		return JPEG, nil
	case data[0] == 0x89 && data[1] == 'P' && data[2] == 'N' && data[3] == 'G':
		return PNG, nil
	case data[0] == 'G' && data[1] == 'I' && data[2] == 'F':
		return GIF, nil
	case data[0] == 'B' && data[1] == 'M':
		return BMP, nil
	default:
		return UNKNOWN, nil
	}
}

func GetPIDByExeName(exeName string) (uint32, error) {
	procs, err := process.Processes()
	if err != nil {
		return 0, err
	}

	for _, p := range procs {
		name, err := p.Name()
		if err == nil && name == exeName {
			return uint32(p.Pid), nil
		}
	}

	return 0, fmt.Errorf("no process found with exe name: %s", exeName)
}

func convertForDisplay(src image.Image) []byte {
	// Resize to 50x50
	fmt.Println("Converting icon to for display")
	fmt.Println("Resize to 50x50")
	resizedImg := resize.Resize(60, 60, src, resize.Lanczos3)

	// Create a blank canvas of size 128x64
	fmt.Println("Create new 128x64 image")
	canvas := image.NewRGBA(image.Rect(0, 0, 128, 64))

	// Compute the top-left corner coordinates for centering the image
	startX := (canvas.Bounds().Dx() - resizedImg.Bounds().Dx()) / 2
	startY := (canvas.Bounds().Dy() - resizedImg.Bounds().Dy()) / 2

	fmt.Println("Draw image on center")
	// Draw the resized image onto the canvas
	for y := 0; y < resizedImg.Bounds().Dy(); y++ {
		for x := 0; x < resizedImg.Bounds().Dx(); x++ {
			canvas.Set(startX+x, startY+y, resizedImg.At(x, y))
		}
	}

	// Convert the canvas to black and white
	fmt.Println("Convert to black and white")
	bwImg := toBlackAndWhite(canvas)

	fmt.Println("Coverting to 1 bit image")
	buf, _ := encode1BitBMP(bwImg)

	f, err := os.Create("img.png")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	if err = png.Encode(f, bwImg); err != nil {
		log.Printf("failed to encode: %v", err)
	}

	return buf
}

func encode1Bit(img image.Image) []byte {
	sz := img.Bounds()
	buff := new(bytes.Buffer)

	var currentByte uint8
	var bitPosition uint8 = 7

	for y := sz.Min.Y; y < sz.Max.Y; y++ {
		for x := sz.Min.X; x < sz.Max.X; x++ {
			r, g, b, _ := img.At(x, y).RGBA()

			// Calculate the luminance. Using simplified method: (R+G+B)/3
			lum := (r + g + b) / 3

			// If the pixel is white, set the corresponding bit to 1
			if lum > 0x8000 {
				currentByte |= (1 << bitPosition)
			}

			if bitPosition == 0 { // If we've set all bits for the current byte
				buff.WriteByte(currentByte)
				currentByte = 0
				bitPosition = 7
			} else {
				bitPosition--
			}
		}
	}

	// Write any remaining bits
	if bitPosition != 7 {
		buff.WriteByte(currentByte)
	}

	return buff.Bytes()
}
func encode1BitBMP(img *image.Gray) ([]byte, error) {
	var buf bytes.Buffer

	// Screw headers we don't need them anyway

	// File header
	// fileHeader := []byte("BM")
	// fileSize := make([]byte, 4)
	// dataOffset := make([]byte, 4)
	// binary.LittleEndian.PutUint32(dataOffset, 62) // 14 (file header) + 40 (info header) + 8 (color table)
	// buf.Write(fileHeader)
	// buf.Write(fileSize)
	// buf.Write([]byte{0, 0, 0, 0}) // Reserved
	// buf.Write(dataOffset)

	// Info header
	// infoHeaderSize := make([]byte, 4)
	// binary.LittleEndian.PutUint32(infoHeaderSize, 40)
	// width := make([]byte, 4)
	// height := make([]byte, 4)
	// binary.LittleEndian.PutUint32(width, uint32(img.Bounds().Dx()))
	// binary.LittleEndian.PutUint32(height, uint32(img.Bounds().Dy()))
	// buf.Write(infoHeaderSize)
	// buf.Write(width)
	// buf.Write(height)
	// buf.Write([]byte{1, 0})       // Planes
	// buf.Write([]byte{1, 0})       // Bit count
	// buf.Write(make([]byte, 4))    // Compression
	// buf.Write(make([]byte, 4))    // Size image
	// buf.Write(make([]byte, 4))    // X pixels per meter
	// buf.Write(make([]byte, 4))    // Y pixels per meter
	// buf.Write([]byte{2, 0, 0, 0}) // Colors used
	// buf.Write([]byte{2, 0, 0, 0}) // Colors important

	// // Color table
	// buf.Write([]byte{0, 0, 0, 0})       // Black
	// buf.Write([]byte{255, 255, 255, 0}) // White

	// Pixel data
	for y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {
		var byteValue byte = 0
		var bitPos uint8 = 0
		for x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {
			if img.GrayAt(x, y).Y > 127 {
				byteValue |= (1 << (7 - bitPos))
			}
			bitPos++
			if bitPos == 8 || x == img.Bounds().Max.X-1 {
				buf.WriteByte(byteValue)
				byteValue = 0
				bitPos = 0
			}
		}
	}

	// Update file size in file header
	// binary.LittleEndian.PutUint32(fileSize, uint32(buf.Len()))
	// copy(buf.Bytes()[2:6], fileSize)

	return buf.Bytes(), nil
}

func toBlackAndWhite(src image.Image) *image.Gray {
	bounds := src.Bounds()
	dst := image.NewGray(bounds)

	for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
		for x := bounds.Min.X; x < bounds.Max.X; x++ {
			c := color.GrayModel.Convert(src.At(x, y)).(color.Gray)
			if c.Y > 127 {
				dst.Set(x, y, color.White)
			} else {
				dst.Set(x, y, color.Black)
			}
		}
	}

	return dst
}
